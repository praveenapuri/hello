powershell -NoProfile -ExecutionPolicy Bypass -Command {
  # === EDIT THESE ===
  $DocName = "Win-Root-Free-CMD"     # ← your existing SSM Command document name
  $Region  = "us-east-1"             # ← region
  # Optional: SSM document parameters (name -> list of strings). Leave empty if none.
  # Examples:
  # $DocParams = @{ DriveLetters = @("C","D") }
  # $DocParams = @{ ThresholdPct = @("15") }
  $DocParams = @{}

  # Build CLI args, avoiding quoting issues by writing params (if any) to a temp JSON file
  $args = @(
    "ssm","send-command",
    "--document-name", $DocName,
    "--targets", "Key=PlatformTypes,Values=Windows",
    "--region", $Region,
    "--query","Command.CommandId",
    "--output","text"
  )

  $tmp = $null
  if ($DocParams.Count -gt 0) {
    $tmp = [System.IO.Path]::GetTempFileName()
    # Convert to the structure SSM expects: { "ParamName": ["val1","val2"] }
    $paramJson = ($DocParams.GetEnumerator() | ForEach-Object {
      @{ ($_.Key) = [System.String[]]$_.Value }
    } | ConvertTo-Json)
    Set-Content -Path $tmp -Value $paramJson -Encoding UTF8
    $args += @("--parameters","file://$tmp")
  }

  $cmdId = aws @args
  if (-not $cmdId) { throw "Failed to start SSM command." }
  Write-Host "Started SSM CommandId: $cmdId"

  # Wait for completion
  $terminal = @("Success","Cancelled","Failed","TimedOut","Incomplete")
  do {
    Start-Sleep -Seconds 3
    $status = aws ssm list-commands --command-id $cmdId --region $Region --query "Commands[0].Status" --output text 2>$null
    if (-not $status) { $status = "Pending" }
    Write-Host "Status: $status"
  } while ($terminal -notcontains $status)

  # Fetch outputs and consolidate
  $inv = aws ssm list-command-invocations --command-id $cmdId --details --region $Region --output json | ConvertFrom-Json
  $all = @()
  foreach ($ci in $inv.CommandInvocations) {
    $out = $ci.CommandPlugins[0].Output
    if ([string]::IsNullOrWhiteSpace($out)) { continue }
    try {
      $obj = $out | ConvertFrom-Json
      if ($obj -is [System.Collections.IEnumerable] -and -not ($obj.PSObject.TypeNames -contains 'System.Collections.Hashtable')) { $all += $obj } else { $all += $obj }
    } catch {
      $all += @{ InstanceId = $ci.InstanceId; Raw = $out; ParseError = $true }
    }
  }

  $outPath = Join-Path (Get-Location) ("consolidated-ssm-output-" + $cmdId + ".json")
  $all | ConvertTo-Json -Depth 8 | Set-Content -Encoding UTF8 $outPath
  Write-Host "Consolidated output saved to: $outPath"

  if ($tmp) { Remove-Item $tmp -ErrorAction SilentlyContinue }
}
