# main.tf

terraform {
  backend "s3" {}
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 4.0"
    }
  }
}

variable "region" {
  type    = string
  default = "us-east-1"
}

# Choose your planning capacity for the storage utilization gauge (EFS is elastic).
# Example: 10 TiB
variable "efs_target_capacity_bytes" {
  description = "Target capacity (bytes) used to compute EFS storage utilization %."
  type        = number
  default     = 10995116277760
}

variable "lambda_function_names" {
  type    = list(string)
  default = []
}

provider "aws" {
  region = var.region
}

# ---------------- EC2 discovery (as in your file) ----------------
data "aws_instances" "monitored_instances" {
  filter {
    name   = "instance-state-name"
    values = ["running", "pending"]
  }
}

data "aws_instance" "instance_details" {
  for_each    = toset(data.aws_instances.monitored_instances.ids)
  instance_id = each.key
}

# ---------------- EFS discovery via AWS CLI (no fixed IDs) ----------------
# Requires: aws & jq on PATH, with credentials for the same account/region.
data "external" "efs_list" {
  program = ["bash", "-lc", <<'BASH'
set -euo pipefail
aws efs describe-file-systems --output json \
| jq '{ids: [.FileSystems[].FileSystemId]}'
BASH
  ]
}

# ---------------- Locals ----------------
locals {
  # ---------- EC2 ----------
  ec2_instances = values(data.aws_instance.instance_details)

  cpu_metrics = [
    for inst in local.ec2_instances : [
      "AWS/EC2", "CPUUtilization", "InstanceId", inst.id,
      { "label" : "CPU - ${coalesce(inst.tags.Name, inst.id)}" }
    ]
  ]
  mem_metrics = [
    for inst in local.ec2_instances : [
      "CWAgent", "mem_used_percent", "InstanceId", inst.id,
      { "label" : "%MEM - ${coalesce(inst.tags.Name, inst.id)}" }
    ]
  ]
  disk_metrics = [
    for inst in local.ec2_instances : [
      "CWAgent", "disk_used_percent", "InstanceId", inst.id,
      { "label": "%Disk - ${coalesce(inst.tags.Name, inst.id)}" }
    ]
  ]
  ec2_all_metrics  = concat(local.cpu_metrics, local.mem_metrics, local.disk_metrics)
  ec2_metrics_json = jsonencode(local.ec2_all_metrics)

  # ---------- Lambda ----------
  lambda_invocations = [
    for fn in var.lambda_function_names : [
      "AWS/Lambda", "Invocations", "FunctionName", fn, { "label": "Invocations - ${fn}" }
    ]
  ]
  lambda_errors = [
    for fn in var.lambda_function_names : [
      "AWS/Lambda", "Errors", "FunctionName", fn, { "label": "Errors - ${fn}" }
    ]
  ]
  lambda_duration = [
    for fn in var.lambda_function_names : [
      "AWS/Lambda", "Duration", "FunctionName", fn, { "label": "Duration - ${fn}" }
    ]
  ]
  lambda_throttles = [
    for fn in var.lambda_function_names : [
      "AWS/Lambda", "Throttles", "FunctionName", fn, { "label": "Throttles - ${fn}" }
    ]
  ]
  lambda_concurrent = [
    for fn in var.lambda_function_names : [
      "AWS/Lambda", "ConcurrentExecutions", "FunctionName", fn, { "label": "Concurrent - ${fn}" }
    ]
  ]
  lambda_all_metrics  = concat(local.lambda_invocations, local.lambda_errors, local.lambda_duration, local.lambda_throttles, local.lambda_concurrent)
  lambda_metrics_json = jsonencode(local.lambda_all_metrics)

  # ---------- SSM RunCommand ----------
  ssm_metrics = [
    [ "AWS/SSM-RunCommand", "CommandsSucceeded",        { "label": "SSM Commands Succeeded" } ],
    [ "AWS/SSM-RunCommand", "CommandsFailed",           { "label": "SSM Commands Failed" } ],
    [ "AWS/SSM-RunCommand", "CommandsDeliveryTimedOut", { "label": "SSM Commands DeliveryTimedOut" } ]
  ]
  ssm_metrics_json = jsonencode(local.ssm_metrics)

  # ---------- EFS IDs from external ----------
  efs_ids = try(data.external.efs_list.result.ids, [])

  # Helper to create safe IDs for metric-math identifiers (no dashes)
  efs_id_to_token = { for id in local.efs_ids : id => replace(id, "-", "") }

  # ---------- EFS gauge metrics (per filesystem, single window) ----------
  # For each FileSystemId we add:
  #   1) MeteredIOBytes (Sum, 60s)            -> id mi_<token>
  #   2) PermittedThroughput (Avg, 60s)       -> id pt_<token>
  #   3) (mi/60)/pt*100                       -> id tp_<token>, label "<fs>-FileServerDiskThroughputUtilization"
  #   4) StorageBytes (Avg, 300s)             -> id sb_<token>
  #   5) sb/target_capacity*100               -> id su_<token>, label "<fs>-StorageCapacityUtilization"
  efs_gauge_metrics = flatten([
    for fs_id in local.efs_ids : [
      [
        "AWS/EFS", "MeteredIOBytes", "FileSystemId", fs_id,
        { "stat": "Sum", "period": 60, "id": "mi_${local.efs_id_to_token[fs_id]}" }
      ],
      [
        "AWS/EFS", "PermittedThroughput", "FileSystemId", fs_id,
        { "stat": "Average", "period": 60, "id": "pt_${local.efs_id_to_token[fs_id]}" }
      ],
      [
        { "expression": "(mi_${local.efs_id_to_token[fs_id]}/60)/pt_${local.efs_id_to_token[fs_id]}*100",
          "id": "tp_${local.efs_id_to_token[fs_id]}",
          "label": "${fs_id}-FileServerDiskThroughputUtilization"
        }
      ],
      [
        "AWS/EFS", "StorageBytes", "FileSystemId", fs_id,
        { "stat": "Average", "period": 300, "id": "sb_${local.efs_id_to_token[fs_id]}" }
      ],
      [
        { "expression": "sb_${local.efs_id_to_token[fs_id]} / ${var.efs_target_capacity_bytes} * 100",
          "id": "su_${local.efs_id_to_token[fs_id]}",
          "label": "${fs_id}-StorageCapacityUtilization"
        }
      ]
    ]
  ])

  efs_gauge_json = jsonencode(local.efs_gauge_metrics)

  # ---------- Dashboard ----------
  dashboard_body = <<-EOF
{
  "start": "-PT24H",
  "periodOverride": "inherit",
  "widgets": [
    {
      "type": "metric",
      "x": 0, "y": 0, "width": 24, "height": 6,
      "properties": {
        "metrics": ${local.ec2_metrics_json},
        "view": "gauge",
        "region": "${var.region}",
        "period": 300,
        "stat": "Average",
        "title": "EC2-Health",
        "yAxis": { "left": { "min": 0, "max": 100 } }
      }
    },
    {
      "type": "metric",
      "x": 0, "y": 7, "width": 24, "height": 6,
      "properties": {
        "metrics": ${local.lambda_metrics_json},
        "view": "timeSeries",
        "region": "${var.region}",
        "period": 300,
        "title": "Lambda-Health"
      }
    },
    {
      "type": "metric",
      "x": 0, "y": 21, "width": 24, "height": 6,
      "properties": {
        "metrics": ${local.ssm_metrics_json},
        "view": "timeSeries",
        "region": "${var.region}",
        "period": 60,
        "title": "SSM RunCommand Health"
      }
    },

    # --------------- EFS gauge (single window, multiple needles) ---------------
    {
      "type": "metric",
      "x": 0, "y": 35, "width": 24, "height": 6,
      "properties": {
        "region": "${var.region}",
        "view": "gauge",
        "title": "EFS - StorageCapacityUtilization & FileServerDiskThroughputUtilization (%)",
        "period": 60,
        "stat": "Average",
        "yAxis": { "left": { "min": 0, "max": 100 } },
        "metrics": ${jsonencode(local.efs_gauge_metrics)}
      }
    }
    # --------------- end EFS gauge --------------------------------------------
  ]
}
EOF
}

resource "aws_cloudwatch_dashboard" "infra_health" {
  dashboard_name = "Infra-Health-Overview"
  dashboard_body = local.dashboard_body
}
