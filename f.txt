terraform {
  backend "s3" {}
}

# -----------------------
# EC2 instances discovery
# -----------------------
data "aws_instances" "monitored_instances" {
  filter {
    name   = "instance-state-name"
    values = ["running", "pending"]
  }
}

data "aws_instance" "instance_details" {
  for_each    = toset(data.aws_instances.monitored_instances.ids)
  instance_id = each.key
}

# -----------------------
# Locals
# -----------------------
locals {
  # extract Lambda names from var
  lambda_function_names = var.lambda_function_names

  # Identify instance sets based on Name contains "chronicles" (case-insensitive)
  csr_ids = toset([
    for inst in values(data.aws_instance.instance_details) : inst.id
    if length(regexall("chronicles", lower(try(inst.tags.Name, "")))) > 0
  ])

  other_ids = setsubtract(
    toset([for inst in values(data.aws_instance.instance_details) : inst.id]),
    local.csr_ids
  )

  # Friendly display name per instance
  name_of = {
    for inst in values(data.aws_instance.instance_details) :
    inst.id => coalesce(try(inst.tags.Name, null), inst.id)
  }

  # Drives you want to chart for Windows machines:
  win_disk_letters = ["C:"]

  # ---------------- CPU (common) ----------------
  cpu_csr = [
    for iid in local.csr_ids : [
      "AWS/EC2","CPUUtilization","InstanceId",iid,
      { label = "CPU % - ${lookup(local.name_of, iid, iid)}", stat = "Average", period = 300 }
    ]
  ]

  cpu_other = [
    for iid in local.other_ids : [
      "AWS/EC2","CPUUtilization","InstanceId",iid,
      { label = "CPU % - ${lookup(local.name_of, iid, iid)}", stat = "Average", period = 300 }
    ]
  ]

  # ---------------- Memory ----------------
  # Chronicles = Linux memory
  mem_linux_csr = [
    for iid in local.csr_ids : [
      "CWAgent","mem_used_percent","InstanceId",iid,
      { label = "Mem Used % - ${lookup(local.name_of, iid, iid)}", stat = "Average", period = 300 }
    ]
  ]

  # Other = Windows memory (required extra dimension)
  mem_windows_other = [
    for iid in local.other_ids : [
      "CWAgent","Memory % Committed Bytes In Use",
      "InstanceId",iid,
      "objectname","Memory",
      { label = "Mem Used % - ${lookup(local.name_of, iid, iid)}", stat = "Average", period = 300 }
    ]
  ]

  # ---------------- Disk ----------------
  # Chronicles = Linux disk used %
  disk_linux_csr = [
    for iid in local.csr_ids : [
      "CWAgent","disk_used_percent","InstanceId",iid,
      { label = "Disk Used % - ${lookup(local.name_of, iid, iid)}", stat = "Average", period = 300 }
    ]
  ]

  # Other = Windows disk (NO metric math; show Free % directly with required dims)
  disk_win_other_free = flatten([
    for iid in tolist(local.other_ids) : [
      for letter in local.win_disk_letters : [
        "CWAgent","LogicalDisk % Free Space",
        "InstanceId",iid,
        "objectname","LogicalDisk",
        "instance",letter,
        { label = "Disk Free % (${letter}) - ${lookup(local.name_of, iid, iid)}", stat = "Average", period = 300 }
      ]
    ]
  ])

  # ---------------- Final per-window metric lists (arrays only) ----------------
  # Chronicles window: Linux-only (CPU + Mem Used % + Disk Used %)
  metrics_csr = concat(
    local.cpu_csr,
    local.mem_linux_csr,
    local.disk_linux_csr
  )

  # Other window: Windows-only (CPU + Mem Used % + Disk Free %)
  metrics_other = concat(
    local.cpu_other,
    local.mem_windows_other,
    local.disk_win_other_free
  )

  # ---------------- Non-EC2 metrics (no expressions anywhere) ----------------

  # Lambda (per function)
  lambda_invocations = [
    for fn in local.lambda_function_names : [
      "AWS/Lambda","Invocations","FunctionName",fn,
      { label : "Invocations - ${fn}", stat : "Sum", period : 300 }
    ]
  ]
  lambda_errors = [
    for fn in local.lambda_function_names : [
      "AWS/Lambda","Errors","FunctionName",fn,
      { label : "Errors - ${fn}", stat : "Sum", period : 300 }
    ]
  ]
  lambda_duration = [
    for fn in local.lambda_function_names : [
      "AWS/Lambda","Duration","FunctionName",fn,
      { label : "Duration - ${fn}", stat : "Average", period : 300 }
    ]
  ]
  lambda_throttles = [
    for fn in local.lambda_function_names : [
      "AWS/Lambda","Throttles","FunctionName",fn,
      { label : "Throttles - ${fn}", stat : "Sum", period : 300 }
    ]
  ]
  lambda_concurrent = [
    for fn in local.lambda_function_names : [
      "AWS/Lambda","ConcurrentExecutions","FunctionName",fn,
      { label : "Concurrent - ${fn}", stat : "Maximum", period : 300 }
    ]
  ]
  all_lambda_metrics = concat(
    local.lambda_invocations,
    local.lambda_errors,
    local.lambda_duration,
    local.lambda_throttles,
    local.lambda_concurrent
  )

  # EFS: PercentIOLimit & StorageBytes (per FileSystemId)
  efs_percent_io = [
    for id in var.efs_file_system_ids : [
      "AWS/EFS","PercentIOLimit","FileSystemId",id,
      { label : "EFS-PercentIOLimit - ${id}", stat : "Average", period : 300 }
    ]
  ]
  efs_storage = [
    for id in var.efs_file_system_ids : [
      "AWS/EFS","StorageBytes","FileSystemId",id,
      { label : "EFS-StorageBytes - ${id}", stat : "Average", period : 300 }
    ]
  ]
  efs_all_metrics = concat(local.efs_percent_io, local.efs_storage)

  # FSx: StorageCapacityUtilization & FileServerDiskThroughputUtilization (per FileSystemId)
  fsx_storage_util = [
    for id in var.fsx_file_system_ids : [
      "AWS/FSx","StorageCapacityUtilization","FileSystemId",id,
      { label : "FSx-StorageCapacityUtilization - ${id}", stat : "Average", period : 300 }
    ]
  ]
  fsx_disk_tp_util = [
    for id in var.fsx_file_system_ids : [
      "AWS/FSx","FileServerDiskThroughputUtilization","FileSystemId",id,
      { label : "FSx-FileServerDiskThroughputUtilization - ${id}", stat : "Average", period : 300 }
    ]
  ]
  fsx_all_metrics = concat(local.fsx_storage_util, local.fsx_disk_tp_util)

  # SSM RunCommand status (namespace with no dimensions is OK)
  ssm_jobs_metrics = [
    ["AWS/SSM-RunCommand","CommandsInProgress",{ label : "SSM-CommandsInProgress", stat : "Sum", period : 60 }],
    ["AWS/SSM-RunCommand","CommandsSucceeded",{ label : "SSM-CommandsSucceeded", stat : "Sum", period : 60 }],
    ["AWS/SSM-RunCommand","CommandsFailed",{ label : "SSM-CommandsFailed", stat : "Sum", period : 60 }],
    ["AWS/SSM-RunCommand","CommandsCancelled",{ label : "SSM-CommandsCancelled", stat : "Sum", period : 60 }],
    ["AWS/SSM-RunCommand","CommandsTimedOut",{ label : "SSM-CommandsTimedOut", stat : "Sum", period : 60 }],
    ["AWS/SSM-RunCommand","CommandsDeliveryTimedOut",{ label : "SSM-CommandsDeliveryTimedOut", stat : "Sum", period : 60 }]
  ]

  # NLB (no expressions): show namespace-level series without dims
  nlb_metrics_simple = [
    ["AWS/NetworkELB","ActiveFlowCount",{ label : "ActiveFlowCount", stat : "Sum", period : 60 }],
    ["AWS/NetworkELB","RejectedFlowCount",{ label : "RejectedFlowCount", stat : "Sum", period : 60 }]
  ]

  # ALB (no expressions)
  alb_metrics_simple = [
    ["AWS/ApplicationELB","RequestCount",{ label : "RequestCount", stat : "Sum", period : 60 }],
    ["AWS/ApplicationELB","HTTPCode_ELB_4XX_Count",{ label : "HTTPCode_ELB_4XX_Count", stat : "Sum", period : 60 }],
    ["AWS/ApplicationELB","HTTPCode_ELB_5XX_Count",{ label : "HTTPCode_ELB_5XX_Count", stat : "Sum", period : 60 }]
  ]

  # ALB TargetGroup (no expressions)
  alb_tg_metrics_simple = [
    ["AWS/ApplicationELB","HTTPCode_Target_3XX_Count",{ label : "HTTPCode_Target_3XX_Count", stat : "Sum", period : 300 }],
    ["AWS/ApplicationELB","HTTPCode_Target_4XX_Count",{ label : "HTTPCode_Target_4XX_Count", stat : "Sum", period : 300 }],
    ["AWS/ApplicationELB","HTTPCode_Target_5XX_Count",{ label : "HTTPCode_Target_5XX_Count", stat : "Sum", period : 300 }],
    ["AWS/ApplicationELB","TargetResponseTime",{ label : "TargetResponseTime", stat : "Average", period : 300 }]
  ]

  # EBS (no expressions): show a couple of common metrics directly
  ebs_simple = [
    ["AWS/EBS","VolumeThroughputPercentage",{ label : "VolumeThroughputPercentage", stat : "Average", period : 300 }],
    ["AWS/EBS","VolumeQueueLength",{ label : "VolumeQueueLength", stat : "Average", period : 300 }]
  ]

  # --- Dashboard JSON (all widgets) ---
  final = <<-EOF
{
  "widgets" : [
    {
      "type": "metric",
      "x": 0,
      "y": 0,
      "width": 12,
      "height": 6,
      "properties": {
        "title": "EC2 – Chronicles (CPU, Mem Used %, Disk Used %)",
        "region": "${var.region}",
        "view": "gauge",
        "stat": "Average",
        "period": 300,
        "yAxis": { "left": { "min": 0, "max": 100 } },
        "metrics": ${jsonencode(local.metrics_csr)}
      }
    },
    {
      "type": "metric",
      "x": 0,
      "y": 6,
      "width": 24,
      "height": 6,
      "properties": {
        "title": "EC2 – Other (CPU, Mem Used %, Disk Free %)",
        "region": "${var.region}",
        "view": "gauge",
        "stat": "Average",
        "period": 300,
        "yAxis": { "left": { "min": 0, "max": 100 } },
        "metrics": ${jsonencode(local.metrics_other)}
      }
    },
    {
      "type": "metric",
      "x": 0,
      "y": 7,
      "width": 12,
      "height": 6,
      "properties": {
        "title": "Lambda-Health",
        "region": "${var.region}",
        "view": "timeSeries",
        "period": 300,
        "metrics": ${jsonencode(local.all_lambda_metrics)}
      }
    },
    {
      "type": "metric",
      "x": 12,
      "y": 0,
      "width": 12,
      "height": 6,
      "properties": {
        "title": "EFS - PercentIOLimit & StorageBytes",
        "region": "${var.region}",
        "view": "timeSeries",
        "period": 300,
        "metrics": ${jsonencode(local.efs_all_metrics)}
      }
    },
    {
      "type": "metric",
      "x": 12,
      "y": 7,
      "width": 12,
      "height": 6,
      "properties": {
        "title": "FSx - StorageCapacityUtilization & FileServerDiskThroughputUtilization (%)",
        "region": "${var.region}",
        "view": "gauge",
        "yAxis": { "left": { "min": 0, "max": 100 } },
        "period": 60,
        "metrics": ${jsonencode(local.fsx_all_metrics)}
      }
    },
    {
      "type": "metric",
      "x": 12,
      "y": 13,
      "width": 12,
      "height": 6,
      "properties": {
        "title": "SSM Jobs - RunCommand Status",
        "region": "${var.region}",
        "view": "timeSeries",
        "period": 60,
        "stat": "Sum",
        "metrics": ${jsonencode(local.ssm_jobs_metrics)}
      }
    },
    {
      "type": "metric",
      "x": 0,
      "y": 35,
      "width": 24,
      "height": 6,
      "properties": {
        "title": "NLB-Health : Active & Rejected Flows",
        "region": "${var.region}",
        "view": "timeSeries",
        "period": 60,
        "stat": "Sum",
        "metrics": ${jsonencode(local.nlb_metrics_simple)}
      }
    },
    {
      "type": "metric",
      "x": 0,
      "y": 7,
      "width": 12,
      "height": 6,
      "properties": {
        "title": "ALB-Health : Requests, 4XX, 5XX",
        "region": "${var.region}",
        "view": "timeSeries",
        "period": 60,
        "stat": "Sum",
        "metrics": ${jsonencode(local.alb_metrics_simple)}
      }
    },
    {
      "type": "metric",
      "x": 12,
      "y": 7,
      "width": 12,
      "height": 6,
      "properties": {
        "title": "ALB TargetGroup Health",
        "region": "${var.region}",
        "view": "timeSeries",
        "period": 60,
        "stat": "Average",
        "metrics": ${jsonencode(local.alb_tg_metrics_simple)}
      }
    },
    {
      "type": "metric",
      "x": 0,
      "y": 7,
      "width": 12,
      "height": 6,
      "properties": {
        "title": "EBS-Health",
        "region": "${var.region}",
        "view": "gauge",
        "period": 300,
        "stat": "Average",
        "yAxis": { "left": { "min": 0, "max": 100 } },
        "metrics": ${jsonencode(local.ebs_simple)}
      }
    }
  ]
}
EOF
}

# -----------------------
# Outputs
# -----------------------
output "raw_json_string" {
  value = replace(local.final, "\n", " ")
}

# -----------------------
# CloudWatch Dashboard
# -----------------------
resource "aws_cloudwatch_dashboard" "health" {
  dashboard_name = "EPIC-Infra-Health"
  dashboard_body = local.final
}
