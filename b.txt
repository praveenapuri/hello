terraform {
  backend "s3" {}
}

# -----------------------
# EC2 instances discovery
# -----------------------
data "aws_instances" "monitored_instances" {
  filter {
    name   = "instance-state-name"
    values = ["running", "pending"]
  }
}

data "aws_instance" "instance_details" {
  for_each    = toset(data.aws_instances.monitored_instances.ids)
  instance_id = each.key
}

# -----------------------
# Locals
# -----------------------
locals {
  # extract Lambda names from var
  lambda_function_names = var.lambda_function_names
  # --- Split instances into Chronicle & Support/Rel vs Others ---
  cs_instance_ids = toset([
    for inst in values(data.aws_instance.instance_details) : inst.id
    if length(
      regexall("(chronicle|chronicles|support|\\brel\\b)", lower(lookup(inst.tags, "Name", "")))
    ) > 0
  ])

  other_instance_ids = setsubtract(
    toset([for inst in values(data.aws_instance.instance_details) : inst.id]),
    local.cs_instance_ids
  )
  # --- EC2 Metrics Generation (UNCHANGED) ---
  cpu_metrics = [
    for instance in values(data.aws_instance.instance_details) : [
      "AWS/EC2", "CPUUtilization", "InstanceId", instance.id,
      { "label" : "CPU - ${coalesce(instance.tags.Name, instance.id)}" }
    ]
  ]
  # Pretty names by instance
  name_of = {
    for inst in values(data.aws_instance.instance_details) :
    inst.id => try(inst.tags.Name, inst.id)
  }

  # Group by Name tag (case-insensitive)
  chronicle_ids = toset([
    for inst in values(data.aws_instance.instance_details) : inst.id
    if length(regexall("(\\bchronicle\\b|\\bchronicles\\b)", lower(lookup(inst.tags, "Name", "")))) > 0
  ])

  support_ids = toset([
    for inst in values(data.aws_instance.instance_details) : inst.id
    if length(regexall("\\bsupport\\b", lower(lookup(inst.tags, "Name", "")))) > 0
  ])

  rel_ids = toset([
    for inst in values(data.aws_instance.instance_details) : inst.id
    if length(regexall("\\brel\\b", lower(lookup(inst.tags, "Name", "")))) > 0
  ])

  all_ids   = toset([for inst in values(data.aws_instance.instance_details) : inst.id])
  csr_ids   = setunion(local.chronicle_ids, local.support_ids, local.rel_ids)
  other_ids = setsubtract(local.all_ids, local.csr_ids)

  cpu_metrics_cs = [
    for instance in values(data.aws_instance.instance_details) :
    ["AWS/EC2","CPUUtilization","InstanceId",instance.id,
      {"label":"CPU - ${coalesce(instance.tags.Name, instance.id)}"}]
    if contains(local.cs_instance_ids, instance.id)
  ]
  ############################################
  # Metric arrays (PER-INSTANCE, no combining)
  ############################################

  # --- Linux DISK used % (per instance)
  disk_linux_csr = [
    for iid in local.csr_ids : [
      "CWAgent", "disk_used_percent", "InstanceId", iid,
      {
        label  = "Disk Used % (Linux) - ${lookup(local.name_of, iid, iid)}"
        stat   = "Average"
        period = 300
      }
    ]
  ]

  disk_linux_other = [
    for iid in local.other_ids : [
      "CWAgent", "disk_used_percent", "InstanceId", iid,
      {
        label  = "Disk Used % (Linux) - ${lookup(local.name_of, iid, iid)}"
        stat   = "Average"
        period = 300
      }
    ]
  ]

  # --- Windows DISK used % = 100 - "LogicalDisk % Free Space" (per instance)
  # Build a metric line with an 'id', then an expression referencing that id.
  disk_windows_csr = flatten([
    for idx, iid in tolist(local.csr_ids) : [
      [
        "CWAgent", "LogicalDisk % Free Space", "InstanceId", iid,
        {
          id     = "wfree_${replace(iid, "-", "")}_${idx}"
          label  = "Disk Free % (Windows) - ${lookup(local.name_of, iid, iid)}"
          stat   = "Average"
          period = 300
        }
      ],
      [
        {
          expression = format("100 - %s", "wfree_${replace(iid, "-", "")}_${idx}")
          id         = "wused_${replace(iid, "-", "")}_${idx}"
          label      = "Disk Used % (Windows) - ${lookup(local.name_of, iid, iid)}"
          period     = 300
        }
      ]
    ]
  ])

  disk_windows_other = flatten([
    for idx, iid in tolist(local.other_ids) : [
      [
        "CWAgent", "LogicalDisk % Free Space", "InstanceId", iid,
        {
          id     = "wfree_${replace(iid, "-", "")}_${idx}"
          label  = "Disk Free % (Windows) - ${lookup(local.name_of, iid, iid)}"
          stat   = "Average"
          period = 300
        }
      ],
      [
        {
          expression = format("100 - %s", "wfree_${replace(iid, "-", "")}_${idx}")
          id         = "wused_${replace(iid, "-", "")}_${idx}"
          label      = "Disk Used % (Windows) - ${lookup(local.name_of, iid, iid)}"
          period     = 300
        }
      ]
    ]
  ])

  # --- Linux MEM used % (per instance)
  mem_linux_csr = [
    for iid in local.csr_ids : [
      "CWAgent", "mem_used_percent", "InstanceId", iid,
      {
        label  = "Mem Used % (Linux) - ${lookup(local.name_of, iid, iid)}"
        stat   = "Average"
        period = 300
      }
    ]
  ]

  mem_linux_other = [
    for iid in local.other_ids : [
      "CWAgent", "mem_used_percent", "InstanceId", iid,
      {
        label  = "Mem Used % (Linux) - ${lookup(local.name_of, iid, iid)}"
        stat   = "Average"
        period = 300
      }
    ]
  ]

  # --- Windows MEM used % (per instance)
  mem_windows_csr = [
    for iid in local.csr_ids : [
      "CWAgent", "Memory % Committed Bytes In Use", "InstanceId", iid,
      {
        label  = "Mem Used % (Windows) - ${lookup(local.name_of, iid, iid)}"
        stat   = "Average"
        period = 300
      }
    ]
  ]

  mem_windows_other = [
    for iid in local.other_ids : [
      "CWAgent", "Memory % Committed Bytes In Use", "InstanceId", iid,
      {
        label  = "Mem Used % (Windows) - ${lookup(local.name_of, iid, iid)}"
        stat   = "Average"
        period = 300
      }
    ]
  ]

  # Final lists per window (Linux + Windows shown side-by-side, still per-instance)
  disk_metrics_csr   = concat(local.disk_linux_csr,   local.disk_windows_csr)
  mem_metrics_csr    = concat(local.mem_linux_csr,    local.mem_windows_csr)
  disk_metrics_other = concat(local.disk_linux_other, local.disk_windows_other)
  mem_metrics_other  = concat(local.mem_linux_other,  local.mem_windows_other)

  # Metrics for all other instances
  cpu_metrics_other = [
    for instance in values(data.aws_instance.instance_details) :
    ["AWS/EC2","CPUUtilization","InstanceId",instance.id,
      {"label":"CPU - ${coalesce(instance.tags.Name, instance.id)}"}]
    if contains(local.other_instance_ids, instance.id)
  ]

  # --- Lambda Metrics Generation (UNCHANGED) ---
  lambda_invocations = [
    for fn in local.lambda_function_names : [
      "AWS/Lambda", "Invocations", "FunctionName", fn,
      { "label" : "Invocations - ${fn}" }
    ]
  ]
  lambda_errors = [
    for fn in local.lambda_function_names : [
      "AWS/Lambda", "Errors", "FunctionName", fn,
      { "label" : "Errors - ${fn}" }
    ]
  ]
  lambda_duration = [
    for fn in local.lambda_function_names : [
      "AWS/Lambda", "Duration", "FunctionName", fn,
      { "label" : "Duration - ${fn}" }
    ]
  ]
  lambda_throttles = [
    for fn in local.lambda_function_names : [
      "AWS/Lambda", "Throttles", "FunctionName", fn,
      { "label" : "Throttles - ${fn}" }
    ]
  ]
  lambda_concurrent = [
    for fn in local.lambda_function_names : [
      "AWS/Lambda", "ConcurrentExecutions", "FunctionName", fn,
      { "label" : "Concurrent - ${fn}" }
    ]
  ]

  all_lambda_metrics = concat(
    local.lambda_invocations,
    local.lambda_errors,
    local.lambda_duration,
    local.lambda_throttles,
    local.lambda_concurrent
  )
  lambda_metrics_string = jsonencode(local.all_lambda_metrics)

  # --- EFS Metrics Generation (NEW) ---
  # Use native EFS metrics that work cleanly without metric math:
  # - PercentIOLimit (percentage)
  # - StorageBytes   (absolute bytes)
  efs_percent_io = [
    for id in var.efs_file_system_ids : [
      "AWS/EFS", "PercentIOLimit", "FileSystemId", id,
      { "label" : "EFS-PercentIOLimit - ${id}" }
    ]
  ]
  efs_storage = [
    for id in var.efs_file_system_ids : [
      "AWS/EFS", "StorageBytes", "FileSystemId", id,
      { "label" : "EFS-StorageBytes - ${id}" }
    ]
  ]
  efs_all_metrics = concat(local.efs_percent_io, local.efs_storage)
  efs_metrics_string = jsonencode(local.efs_all_metrics)

  # --- FSx (Windows FS) Metrics Generation (NEW) ---
  # Both are native percentage metrics:
  # - StorageCapacityUtilization
  # - FileServerDiskThroughputUtilization
  fsx_storage_util = [
    for id in var.fsx_file_system_ids : [
      "AWS/FSx", "StorageCapacityUtilization", "FileSystemId", id,
      { "label" : "FSx-StorageCapacityUtilization - ${id}" }
    ]
  ]
  fsx_disk_tp_util = [
    for id in var.fsx_file_system_ids : [
      "AWS/FSx", "FileServerDiskThroughputUtilization", "FileSystemId", id,
      { "label" : "FSx-FileServerDiskThroughputUtilization - ${id}" }
    ]
  ]
  fsx_all_metrics = concat(local.fsx_storage_util, local.fsx_disk_tp_util)
  fsx_metrics_string = jsonencode(local.fsx_all_metrics)

  # --- SSM Jobs (RunCommand) Metrics ---
  # String-only rows + trailing label objects
  ssm_jobs_metrics = [
    ["AWS/SSM-RunCommand", "CommandsInProgress", { "label" : "SSM-CommandsInProgress", "color": "#1E88E5" }],
    ["AWS/SSM-RunCommand", "CommandsSucceeded", { "label" : "SSM-CommandsSucceeded", "color": "#00C853" }],
    ["AWS/SSM-RunCommand", "CommandsFailed", { "label" : "SSM-CommandsFailed", "color": "#FF0000" }],
    ["AWS/SSM-RunCommand", "CommandsCancelled", { "label" : "SSM-CommandsCancelled", "color": "#000000" }],
    ["AWS/SSM-RunCommand", "CommandsTimedOut", { "label" : "SSM-CommandsTimedOut", "color": "#FF8C00" }],
    ["AWS/SSM-RunCommand", "CommandsDeliveryTimedOut", { "label" : "SSM-CommandsDeliveryTimedOut", "color": "#8E24AA" }]
  ]
  ssm_jobs_metrics_string = jsonencode(local.ssm_jobs_metrics)

  # NLB: ActiveFlowCount, RejectedFlowCount (all LoadBalancers)
  nlb_metrics_search = [
    [
      {
        expression = "SEARCH('{AWS/NetworkELB,LoadBalancer} MetricName=\"ActiveFlowCount\"', 'Sum', 60)"
        id         = "nlb_afc"
        color      = "#00FF00"
      }
    ],
    [
      {
        expression = "SEARCH('{AWS/NetworkELB,LoadBalancer} MetricName=\"RejectedFlowCount\"', 'Sum', 60)"
        id         = "nlb_rfc"
        color      = "#FF0000"
      }
    ]
  ]

  # ALB: RequestCount, 4XX, 5XX (all LoadBalancers)
  alb_metrics_search = [
    [
      {
        expression = "SEARCH('{AWS/ApplicationELB,LoadBalancer} MetricName=\"RequestCount\"', 'Sum', 60)"
        id         = "alb_req"
      }
    ],
    [
      {
        expression = "SEARCH('{AWS/ApplicationELB,LoadBalancer} MetricName=\"HTTPCode_ELB_4XX_Count\"', 'Sum', 60)"
        id         = "alb_4xx"
        color      = "#FFA500"
      }
    ],
    [
      {
        expression = "SEARCH('{AWS/ApplicationELB,LoadBalancer} MetricName=\"HTTPCode_ELB_5XX_Count\"', 'Sum', 60)"
        id         = "alb_5xx"
        color      = "#FF0000"
      }
    ]
  ]

  # Strings for injecting into your local.final heredoc
  nlb_metrics_string = jsonencode(local.nlb_metrics_search)
  alb_metrics_string = jsonencode(local.alb_metrics_search)

  # ALB TargetGroup HTTP & Latency (all target groups)
  # Counts use Sum; latency uses Average.
  alb_tg_http_metrics_search = [
    [
      {
        expression = "SEARCH('{AWS/ApplicationELB,LoadBalancer,TargetGroup} MetricName=\"HTTPCode_Target_3XX_Count\"', 'Sum', 300)"
        id         = "tg_3xx"
        color      = "#FFD700"
      }
    ],
    [
      {
        expression = "SEARCH('{AWS/ApplicationELB,LoadBalancer,TargetGroup} MetricName=\"HTTPCode_Target_4XX_Count\"', 'Sum', 300)"
        id         = "tg_4xx"
        color      = "#FFA500"
      }
    ],
    [
      {
        expression = "SEARCH('{AWS/ApplicationELB,LoadBalancer,TargetGroup} MetricName=\"HTTPCode_Target_5XX_Count\"', 'Sum', 300)"
        id         = "tg_5xx"
        color      = "#FF0000"
      }
    ],
    [
      {
        expression = "SEARCH('{AWS/ApplicationELB,LoadBalancer,TargetGroup} MetricName=\"TargetResponseTime\"', 'Average', 300)"
        id         = "tg_trt"
      }
    ]
  ]

  # String for injecting into your local.final heredoc
  alb_tg_http_metrics_string = jsonencode(local.alb_tg_http_metrics_search)

  # EBS metrics via CloudWatch SEARCH (auto-discovers all VolumeId series)
  ebs_latency_tp_search = [
    [
      { expression = "SEARCH('{AWS/EBS,VolumeId} MetricName=\"VolumeTotalReadTime\"', 'Sum', 300)",     id = "ebs_rt", label = "helper: TotalReadTime",  visible = false }
    ],
    [
      { expression = "SEARCH('{AWS/EBS,VolumeId} MetricName=\"VolumeReadOps\"', 'Sum', 300)",           id = "ebs_ro", label = "helper: ReadOps",        visible = false }
    ],
    [
      { expression = "SEARCH('{AWS/EBS,VolumeId} MetricName=\"VolumeThroughputPercentage\"', 'Average', 300)", id = "ebs_tp", label = "helper: Throughput%", visible = false }
    ],
    [
      { expression = "IF(SUM(ebs_ro)>0, SUM(ebs_rt)/SUM(ebs_ro)*1000, 0)", id = "ebs_rl_ms", label = "EBS - VolumeAvgReadLatency (ms)" }
    ],
    [
      { expression = "IF(MAX(ebs_tp)>100, 1, 0)", id = "ebs_te", label = "EBS - ThroughputExceededCheck (0/1)" }
    ]
  ]

  ebs_latency_tp_metrics_string = jsonencode(local.ebs_latency_tp_search)

  # --- Dashboard JSON (CONCAT all widgets) ---
  final = <<-EOF
{
  "widgets" : [
   {
    type       = "metric"
    x          = 0
    y          = 0
    width      = 12
    height     = 3
    properties = {
      title     = "EC2-Health : Chronicle + Support + Rel (Disk)"
      region    = var.region
      view      = "singleValue"
      stat      = "Average"
      period    = 300
      yAxis     = { left = { min = 0, max = 100 } }
      metrics   = local.disk_metrics_csr
      annotations = {
        horizontal = [
          { label = "75% Used Threshold", value = 75, color = "#d13212", fill = "above" }
        ]
      }
    }
  },


  {
    type       = "metric"
    x          = 0
    y          = 3
    width      = 12
    height     = 3
    properties = {
      title     = "EC2-Health : Chronicle + Support + Rel (Memory)"
      region    = var.region
      view      = "singleValue"
      stat      = "Average"
      period    = 300
      yAxis     = { left = { min = 0, max = 100 } }
      metrics   = local.mem_metrics_csr
      annotations = {
        horizontal = [
          { label = "75% Used Threshold", value = 75, color = "#d13212", fill = "above" }
        ]
      }
    }
  },


  {
    type       = "metric"
    x          = 12
    y          = 0
    width      = 12
    height     = 3
    properties = {
      title     = "EC2-Health : Other Instances (Disk)"
      region    = var.region
      view      = "singleValue"
      stat      = "Average"
      period    = 300
      yAxis     = { left = { min = 0, max = 100 } }
      metrics   = local.disk_metrics_other
      annotations = {
        horizontal = [
          { label = "75% Used Threshold", value = 75, color = "#d13212", fill = "above" }
        ]
      }
    }
  },


  {
    type       = "metric"
    x          = 12
    y          = 3
    width      = 12
    height     = 3
    properties = {
      title     = "EC2-Health : Other Instances (Memory)"
      region    = var.region
      view      = "singleValue"
      stat      = "Average"
      period    = 300
      yAxis     = { left = { min = 0, max = 100 } }
      metrics   = local.mem_metrics_other
      annotations = {
        horizontal = [
          { label = "75% Used Threshold", value = 75, color = "#d13212", fill = "above" }
        ]
      }
    }
  },
    {
      "type"   : "metric",
      "x": 0,
      "y": 7,
      "width" :12,
      "height" : 6,
      "properties" :
      {
        "metrics" : ${local.lambda_metrics_string},
        "view": "timeSeries",
        "region" :  "${var.region}",
        "period": 300,
        "title": "Lambda-Health"
      }
    },

    {
      "type"   : "metric",
      "x": 12,
      "y": 0,
      "width" :12,
      "height" : 6,
      "properties" :
      {
        "metrics" : ${local.efs_metrics_string},
        "view": "timeSeries",
        "region" :  "${var.region}",
        "period": 300,
        "title": "EFS - PercentIOLimit & StorageBytes"
      }
    },

    {
      "type"   : "metric",
      "x": 12,
      "y": 7,
      "width" :12,
      "height" : 6,
      "properties" :
      {
        "metrics" : ${local.fsx_metrics_string},
        "view": "gauge",
        "region" :  "${var.region}",
        "yAxis" : {
          "left" : {
            "min" : 0,
            "max" : 100
          }
        },
        "period": 60,
        "title": "FSx - StorageCapacityUtilization & FileServerDiskThroughputUtilization (%)"
      }
    },

    {
      "type": "metric",
      "x": 12,
      "y": 7,
      "width": 12,
      "height": 6,
      "properties": {
        "metrics": ${local.ssm_jobs_metrics_string},
        "view": "timeSeries",
        "region": "${var.region}",
        "period": 60,
        "stat": "Sum",
        "title": "SSM Jobs - RunCommand Status"
      }
    },
    {
      "type": "metric",
      "x": 0,
      "y": 35,
      "width": 24,
      "height": 6,
      "properties": {
        "metrics": ${local.nlb_metrics_string},
        "view": "timeSeries",
        "region": "${var.region}",
        "period": 60,
        "stat": "Sum",
        "title": "NLB-Health : Active & Rejected Flows (all NLBs)"
      }
    },
    {
      "type": "metric",
      "x": 0,
      "y": 7,
      "width": 12,
      "height": 6,
      "properties": {
        "metrics": ${local.alb_metrics_string},
        "view": "timeSeries",
        "region": "${var.region}",
        "period": 60,
        "stat": "Sum",
        "title": "ALB-Health : Requests, 4XX, 5XX (all ALBs)"
      }
    },
    {
      "type": "metric",
      "x": 12,
      "y": 7,
      "width": 12,
      "height": 6,
      "properties": {
        "metrics": ${local.alb_tg_http_metrics_string},
        "view": "timeSeries",
        "region": "${var.region}",
        "period": 60,
        "stat": "Average",
        "title": "ALB TargetGroup Health"
      }
    },
    {
      "type": "metric",
      "x": 0,
      "y": 7,
      "width": 12,
      "height": 6,
      "properties": {
        "metrics": ${local.ebs_latency_tp_metrics_string},
        "view": "gauge",
        "region": "${var.region}",
        "period": 300,
        "stat": "Average",
        "yAxis": { "left": { "min": 0, "max": 100 } },
        "title": "EBS-Health"
      }
    }
  ]
}
EOF
}

# -----------------------
# Outputs
# -----------------------
output "raw_json_string" {
  value = replace(local.final, "\n", " ")
}

# -----------------------
# CloudWatch Dashboard
# -----------------------
resource "aws_cloudwatch_dashboard" "health" {
  dashboard_name = "EPIC-Infra-Health"
  dashboard_body = local.final
}
